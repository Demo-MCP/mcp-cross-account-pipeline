from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any, Optional
import json
import requests
import boto3
import time
import uvicorn

app = FastAPI(title="MCP Broker Service", version="1.0.0")

class AskRequest(BaseModel):
    ask_text: str
    account_id: str = "500330120558"
    region: str = "us-east-1"
    metadata: Dict[str, Any] = {}
    shim_url: str = "http://internal-mcp-internal-alb-2059913293.us-east-1.elb.amazonaws.com"

class AskResponse(BaseModel):
    answer: str
    debug: Dict[str, Any]

@app.get("/health")
async def health_check():
    return {"ok": True}

@app.post("/ask", response_model=AskResponse)
async def ask_question(request: AskRequest):
    start_time = time.time()
    debug = {}
    
    try:
        tools = get_tool_definitions()
        bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
        
        # Initialize conversation
        messages = [{"role": "user", "content": [{"text": request.ask_text}]}]
        system_prompt = """You are an AWS infrastructure assistant. You can help with:
- ECS services, tasks, and cluster information
- CloudFormation stack status and events
- Infrastructure analysis and recommendations

Always use the available tools to get current, accurate information about AWS resources."""
        
        # Agentic loop - continue until Nova provides final answer
        iteration = 0
        while True:
            iteration += 1
            bedrock_start = time.time()
            
            response = bedrock.converse(
                modelId='us.amazon.nova-pro-v1:0',
                messages=messages,
                system=[{"text": system_prompt}],
                toolConfig={"tools": tools},
                inferenceConfig={
                    "maxTokens": 3000,
                    "temperature": 0,
                    "topP": 1
                },
                additionalModelRequestFields={
                    "inferenceConfig": {
                        "topK": 1
                    }
                }
            )
            
            debug[f"bedrock_call_{iteration}_ms"] = int((time.time() - bedrock_start) * 1000)
            
            # Add assistant's response to conversation
            output_message = response['output']['message']
            messages.append(output_message)
            
            # Check if Nova is finished
            if response['stopReason'] != 'tool_use':
                answer = extract_text_from_response(response)
                break
            
            # Execute tools
            tool_results = []
            for block in output_message['content']:
                if 'toolUse' in block:
                    tool_start = time.time()
                    result = execute_tool_call(block, request, debug)
                    debug[f"tool_{block['toolUse']['name']}_iter{iteration}_ms"] = int((time.time() - tool_start) * 1000)
                    
                    tool_results.append({
                        "toolResult": {
                            "toolUseId": block['toolUse']['toolUseId'],
                            "content": [{"json": result}],
                            "status": "success"
                        }
                    })
            
            # Add tool results to conversation
            messages.append({"role": "user", "content": tool_results})
        
        debug["total_ms"] = int((time.time() - start_time) * 1000)
        debug["iterations"] = iteration
        return AskResponse(answer=answer, debug=debug)
        
    except Exception as e:
        debug["error"] = str(e)
        debug["total_ms"] = int((time.time() - start_time) * 1000)
        return AskResponse(answer=f"Error: {str(e)}", debug=debug)

def get_tool_definitions():
    return [
        {
            "toolSpec": {
                "name": "iac_call_tool",
                "description": "Call Infrastructure as Code (CloudFormation) tools for stack status and deployments",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string", "description": "Tool name (e.g., describe_stacks, describe_stack_events)"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "stack_name": {"type": "string", "description": "CloudFormation stack name"}
                                }
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        },
        {
            "toolSpec": {
                "name": "ecs_call_tool",
                "description": "Call ECS (Elastic Container Service) tools for service and task status in account 500330120558",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string", "description": "Always use 'ecs_resource_management'"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "api_operation": {"type": "string", "description": "ECS API operation (ListServices, DescribeServices, ListClusters)"},
                                    "api_params": {"type": "object", "description": "Parameters for the API operation (can be empty {})"},
                                    "account_id": {"type": "string", "description": "AWS account ID, always use '500330120558'"},
                                    "region": {"type": "string", "description": "AWS region, always use 'us-east-1'"}
                                },
                                "required": ["api_operation", "api_params", "account_id", "region"]
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        }
    ]

def call_bedrock_simple(ask_text: str):
    bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
    
    response = bedrock.invoke_model(
        modelId='us.amazon.nova-pro-v1:0',
        body=json.dumps({
            "messages": [
                {"role": "user", "content": [{"text": ask_text}]}
            ],
            "inferenceConfig": {"maxTokens": 1000}
        })
    )
    
    return json.loads(response['body'].read())

def call_bedrock_with_tools(ask_text: str, tools: list):
    bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
    
    system_prompt = """You are an AWS infrastructure assistant. You can help with:
- CloudFormation stack status and deployments (use iac_call_tool)
- ECS service and task status (use ecs_call_tool)

Always use the available tools to get current, accurate information about AWS resources."""

    response = bedrock.invoke_model(
        modelId='us.amazon.nova-pro-v1:0',
        body=json.dumps({
            "messages": [
                {"role": "user", "content": [{"text": f"{system_prompt}\n\nUser question: {ask_text}"}]}
            ],
            "inferenceConfig": {"maxTokens": 1000},
            "toolConfig": {
                "tools": tools
            }
        })
    )
    
    return json.loads(response['body'].read())

def has_tool_calls(bedrock_response):
    content = bedrock_response.get('output', {}).get('message', {}).get('content', [])
    return any(block.get('toolUse') for block in content)

def extract_tool_calls(bedrock_response):
    tool_calls = []
    for block in bedrock_response.get('output', {}).get('message', {}).get('content', []):
        if block.get('toolUse'):
            tool_calls.append(block)
    return tool_calls

def execute_tool_call(tool_call, request: AskRequest, debug: dict):
    tool_name = tool_call['toolUse']['name']
    tool_input = tool_call['toolUse']['input']
    
    # Inject required parameters
    params = tool_input.get('params', {})
    params['account_id'] = request.account_id
    params['region'] = request.region
    params['_metadata'] = request.metadata
    
    # Determine server type
    server = 'iac' if tool_name == 'iac_call_tool' else 'ecs'
    
    try:
        response = requests.post(
            f"{request.shim_url}/call-tool",
            json={
                "server": server,
                "tool": tool_input['tool'],
                "params": params
            },
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    except Exception as e:
        debug[f"shim_error_{tool_name}"] = str(e)
        return {"error": str(e)}

def call_bedrock_with_results(ask_text: str, tools: list, first_response: dict, tool_results: list):
    bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
    
    # Build conversation with tool results
    messages = [
        {"role": "user", "content": [{"text": ask_text}]},
        {"role": "assistant", "content": first_response['output']['message']['content']}
    ]
    
    # Add tool results
    for i, result in enumerate(tool_results):
        tool_call = extract_tool_calls(first_response)[i]
        messages.append({
            "role": "user",
            "content": [{
                "toolResult": {
                    "toolUseId": tool_call['toolUse']['toolUseId'],
                    "content": [{"text": json.dumps(result)[:2000]}]
                }
            }]
        })
    
    response = bedrock.invoke_model(
        modelId='us.amazon.nova-pro-v1:0',
        body=json.dumps({
            "messages": messages,
            "inferenceConfig": {"maxTokens": 1000}
        })
    )
    
    return json.loads(response['body'].read())

def extract_text_from_response(bedrock_response):
    # Nova Lite response format
    if 'output' in bedrock_response and 'message' in bedrock_response['output']:
        content = bedrock_response['output']['message'].get('content', [])
        for block in content:
            if block.get('text'):
                return block['text']
    
    # Fallback for other formats
    content = bedrock_response.get('content', [])
    for block in content:
        if block.get('type') == 'text':
            return block['text']
    return "No text response from model"

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8080)
