from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any, List
import json
import requests
import boto3
import time
import uvicorn

app = FastAPI(title="MCP Broker Service", version="1.0.0")

class AskRequest(BaseModel):
    ask_text: str
    account_id: str = "500330120558"
    region: str = "us-east-1"
    metadata: Dict[str, Any] = {}
    shim_url: str = "http://internal-mcp-internal-alb-2059913293.us-east-1.elb.amazonaws.com"

class AskResponse(BaseModel):
    answer: str
    debug: Dict[str, Any]

@app.get("/health")
async def health_check():
    return {"ok": True}

@app.post("/ask", response_model=AskResponse)
async def ask_question(request: AskRequest):
    start_time = time.time()
    debug = {}
    
    # Initialize conversation history
    messages = [{"role": "user", "content": [{"text": request.ask_text}]}]
    system_prompt = (
        "You are an AWS infrastructure assistant. You help manage ECS and CloudFormation. "
        "If question doesn't provide account_id and region, always use the provided account_id '500330120558' and region 'us-east-1' for tool calls."
    )
    
    try:
        bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
        tools = get_tool_definitions()
        iteration = 0
        answer = "I could not determine an answer."

        # AGENTIC LOOP: Continues until the model provides a final text response
        while iteration < 10:  # Safety limit to prevent infinite loops
            iteration += 1
            call_start = time.time()
            
            response = bedrock.converse(
                modelId='us.amazon.nova-pro-v1:0',
                messages=messages,
                system=[{"text": system_prompt}],
                toolConfig={"tools": tools},
                inferenceConfig={
                    "maxTokens": 4096, 
                    "temperature": 0,  # Vital for structural JSON integrity
                    "topP": 1
                },
                additionalModelRequestFields={
                    "inferenceConfig": {
                        "topK": 1
                    }
                }
            )
            
            debug[f"bedrock_call_{iteration}_ms"] = int((time.time() - call_start) * 1000)
            
            # 1. Add Assistant's response (Thinking + Tool Request) to history
            output_message = response['output']['message']
            messages.append(output_message)
            
            # 2. Check if the model is finished
            if response['stopReason'] != 'tool_use':
                answer = extract_text_from_response(response)
                break
                
            # 3. Handle Tool Calls
            tool_results_content = []
            for block in output_message['content']:
                if 'toolUse' in block:
                    t_use = block['toolUse']
                    t_name = t_use['name']
                    
                    # Execute tool via Shim
                    t_start = time.time()
                    result = execute_tool_logic(t_use, request)
                    debug[f"tool_{t_name}_iter{iteration}_ms"] = int((time.time() - t_start) * 1000)
                    
                    # 4. Format Result using 'json' key (Nova Requirement)
                    tool_results_content.append({
                        "toolResult": {
                            "toolUseId": t_use['toolUseId'],
                            "content": [{"json": result}],
                            "status": "success"
                        }
                    })
            
            # 5. Add Tool Results back to history as a USER role
            messages.append({"role": "user", "content": tool_results_content})

        debug["iterations"] = iteration
        debug["total_ms"] = int((time.time() - start_time) * 1000)
        return AskResponse(answer=answer, debug=debug)

    except Exception as e:
        error_msg = f"Error: {str(e)}"
        print(error_msg)
        return AskResponse(answer=error_msg, debug={"error": str(e), "total_ms": int((time.time() - start_time) * 1000)})

def execute_tool_logic(tool_use, request: AskRequest):
    """Passes model-generated inputs to the MCP Shim Service."""
    t_input = tool_use['input']
    t_name = tool_use['name']
    
    # Map tool name to target MCP server type
    server = 'iac' if 'iac' in t_name else 'ecs'
    
    # Extract params generated by Nova Pro (includes custom account_id and region)
    params = t_input.get('params', {})
    
    # TODO: Add _metadata support to ECS and IAC MCP servers
    # if "_metadata" not in params:
    #     params["_metadata"] = request.metadata
    
    try:
        resp = requests.post(
            f"{request.shim_url}/call-tool",
            json={
                "server": server, 
                "tool": t_input['tool'], 
                "params": params
            },
            timeout=30
        )
        resp.raise_for_status()
        return resp.json()
    except Exception as e:
        return {"error": f"Shim request failed: {str(e)}"}

def get_tool_definitions():
    """
    Returns strict JSON schema tool definitions for Nova Pro.
    Includes custom account_id and region per user requirements.
    """
    return [
        {
            "toolSpec": {
                "name": "ecs_call_tool",
                "description": "Query ECS clusters, services, and tasks in account 500330120558.",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string", "description": "Always use 'ecs_resource_management'"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "api_operation": {"type": "string", "description": "e.g. ListClusters, ListServices"},
                                    "api_params": {"type": "object", "description": "Operation params, e.g. {'cluster': 'name'}"},
                                    "account_id": {"type": "string", "description": "Must be '500330120558'"},
                                    "region": {"type": "string", "description": "Must be 'us-east-1'"}
                                },
                                "required": ["api_operation", "api_params", "account_id", "region"]
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        },
        {
            "toolSpec": {
                "name": "iac_call_tool",
                "description": "Manage CloudFormation stacks and infrastructure as code.",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string", "description": "IAC tool name (e.g. describe_stacks)"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "stack_name": {"type": "string"},
                                    "account_id": {"type": "string", "description": "Must be '500330120558'"},
                                    "region": {"type": "string", "description": "Must be 'us-east-1'"}
                                },
                                "required": ["account_id", "region"]
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        }
    ]

def extract_text_from_response(response):
    """Safely extracts text content from the Bedrock Converse response."""
    content = response['output']['message'].get('content', [])
    for block in content:
        if 'text' in block:
            return block['text']
    return "Task completed successfully."

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8080)
