from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any, List
import json
import requests
import boto3
import time
import uvicorn

app = FastAPI(title="MCP Broker Service", version="1.0.0")

class AskRequest(BaseModel):
    ask_text: str
    account_id: str = "500330120558"
    region: str = "us-east-1"
    metadata: Dict[str, Any] = {}
    shim_url: str = "http://internal-mcp-internal-alb-2059913293.us-east-1.elb.amazonaws.com"

class AskResponse(BaseModel):
    answer: str
    debug: Dict[str, Any]

@app.get("/health")
async def health_check():
    return {"ok": True}

@app.post("/ask", response_model=AskResponse)
async def ask_question(request: AskRequest):
    start_time = time.time()
    debug = {}
    messages = [{"role": "user", "content": [{"text": request.ask_text}]}]
    system_prompt = "You are an AWS assistant. Use tools for ECS (ecs_call_tool) and CloudFormation (iac_call_tool)."
    
    try:
        bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
        tools = get_tool_definitions()
        iteration = 0
        
        # AGENTIC LOOP: Continue as long as Nova needs tools
        while iteration < 10:  # Safety limit
            iteration += 1
            call_start = time.time()
            
            response = bedrock.converse(
                modelId='us.amazon.nova-pro-v1:0',
                messages=messages,
                system=[{"text": system_prompt}],
                toolConfig={"tools": tools},
                inferenceConfig={"maxTokens": 4096, "temperature": 0, "topP": 1},
                additionalModelRequestFields={"inferenceConfig": {"topK": 1}}
            )
            
            debug[f"bedrock_call_{iteration}_ms"] = int((time.time() - call_start) * 1000)
            
            # 1. Add Assistant's "Thinking + Tool Request" to history
            output_message = response['output']['message']
            messages.append(output_message)
            
            # 2. If no more tools needed, we have our final answer
            if response['stopReason'] != 'tool_use':
                answer = extract_text_from_response(response)
                break
                
            # 3. Process Tool Calls
            tool_results_content = []
            for block in output_message['content']:
                if 'toolUse' in block:
                    t_use = block['toolUse']
                    t_name = t_use['name']
                    
                    # Execute
                    t_start = time.time()
                    result = execute_tool_logic(t_use, request)
                    debug[f"tool_{t_name}_iter{iteration}_ms"] = int((time.time() - t_start) * 1000)
                    
                    # 4. Format Result using 'json' key (Nova Requirement)
                    tool_results_content.append({
                        "toolResult": {
                            "toolUseId": t_use['toolUseId'],
                            "content": [{"json": result}],
                            "status": "success"
                        }
                    })
            
            # 5. Add Tool Results back to history and repeat
            messages.append({"role": "user", "content": tool_results_content})

        debug["iterations"] = iteration
        debug["total_ms"] = int((time.time() - start_time) * 1000)
        return AskResponse(answer=answer, debug=debug)

    except Exception as e:
        return AskResponse(answer=f"Error: {str(e)}", debug={"error": str(e)})

def execute_tool_logic(tool_use, request: AskRequest):
    t_name = tool_use['name']
    t_input = tool_use['input']
    
    # Map tool name to server type
    server = 'iac' if 'iac' in t_name else 'ecs'
    
    # Prepare params with account/region injection
    params = t_input.get('params', {})
    params.update({
        "account_id": request.account_id,
        "region": request.region,
        "_metadata": request.metadata
    })
    
    try:
        resp = requests.post(
            f"{request.shim_url}/call-tool",
            json={"server": server, "tool": t_input['tool'], "params": params},
            timeout=30
        )
        return resp.json()
    except Exception as e:
        return {"error": str(e)}

def get_tool_definitions():
    # Strict Nova Pro Schema: Top-level must be object with ONLY type, properties, required
    return [
        {
            "toolSpec": {
                "name": "ecs_call_tool",
                "description": "Manage ECS resources",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string", "description": "Use 'ecs_resource_management'"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "api_operation": {"type": "string"},
                                    "api_params": {"type": "object"}
                                },
                                "required": ["api_operation"]
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        },
        {
            "toolSpec": {
                "name": "iac_call_tool",
                "description": "Manage CloudFormation stacks",
                "inputSchema": {
                    "json": {
                        "type": "object",
                        "properties": {
                            "tool": {"type": "string"},
                            "params": {
                                "type": "object",
                                "properties": {
                                    "stack_name": {"type": "string"}
                                }
                            }
                        },
                        "required": ["tool", "params"]
                    }
                }
            }
        }
    ]

def extract_text_from_response(response):
    for block in response['output']['message']['content']:
        if 'text' in block:
            return block['text']
    return "Complete."

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8080)
